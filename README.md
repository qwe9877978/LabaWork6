
## Лабораторная работа №6

```
Демин Мефодий ИТ-12
```

---

## Задача 1: Система для работы с котами

### Условие
Реализовать класс `Cat`, который:
- Принимает имя кота при создании
- Может мяукнуть один раз (выводит `<Имя>: мяу!`)
- Может мяукнуть N раз (выводит `<Имя>: мяу-мяу-...-мяу!`)
- Должен поддерживать подсчёт количества мяуканий
- Должен работать с коллекциями котов

### Алгоритм решения задачи 1

1. **Интерфейс `IMeowable`**  
   Создан базовый интерфейс с методом `Meow()`, обеспечивающий единообразную работу со всеми "мяукающими" объектами. Это позволяет легко расширять систему (например, добавлять `RobotCat`) без изменения основной логики.

2. **Класс `Cat`**  
   - Хранит имя кота с обязательной валидацией (имя не может быть пустым или `null`)
   - Реализует два метода `Meow()`:
     * Без параметров — выводит одиночное мяуканье в формате `«Имя: мяу!»`
     * С параметром `n` — генерирует строку из `n` повторяющихся "мяу", разделённых дефисами, что реализовано через простой цикл
   - Проверяет корректность входных данных (количество мяуканий > 0)

3. **ШАБЛОН `MeowCounter<T>`**  
   - Использует шаблоны (обобщения) для подсчёта вызовов метода `Meow()`
   - Хранит внутренний счётчик `CallCount`, инкрементируемый при каждом мяуканье
   - Работает с любым типом, реализующим `IMeowable`, благодаря ограничению `where T : IMeowable`
   - Оригинальный объект доступен через публичное свойство `OriginalObject` (для безопасного доступа к имени кота)

4. **Вспомогательные методы в `MeowHelper`**  
   - `MeowAll(IEnumerable<IMeowable>)` — вызывает мяуканье для всех котов в коллекции, игнорируя `null`-элементы
   - `MeowFiveTimes(IMeowable)` — заставляет кота мяукнуть ровно 5 раз с использованием цикла `while`

5. **Глобальное состояние**  
   Для корректного подсчёта всех мяуканий кота (включая те, что выполнялись в других подзаданиях) используется общий экземпляр `MeowCounter<Cat>`, хранящийся на уровне главного меню.

### Тестирование задачи 1

- **Тест 1.1**: Создание кота с пустым именем
  Ожидаемый результат: исключение при пустом имени.
  - Ошибка выполнения: Имя кота не может быть пустым

- **Тест 1.2**: Проверка N-кратного мяуканья при `N ≤ 0`: 
  Ожидаемый результат: исключение при `N ≤ 0`.
  - Неверное количество. Используем значение по умолчанию (3):

- **Тест 1.3**: Коллекция котов. Создание `N ≤ 0` котов:  
  Ожидаемый результат: Ошибка выполнения
  - Неверное количество.

- **Тест 1.4**: Коллекция котов. Создание `N` котов при `N` - символьного типа :  
  Ожидаемый результат: Ошибка выполнения
  - Неверный формат числа.
- **Тест 1.5**: Мяуканье кота. Мяуканье `N` раз при `N` - символьного типа :  
  Ожидаемый результат: Ошибка выполнения
  - Неверный формат числа.

---

## Задача 2: Система для работы с дробями

### Условие
Реализовать класс `Fraction`, который:
- Представляет дробь в виде числителя и знаменателя
- Поддерживает арифметические операции (+, -, *, /) с другими дробями и целыми числами
- Реализует сравнение дробей
- Обеспечивает клонирование объектов
- Кэширует вещественное значение дроби с использованием шаблонов

### Алгоритм решения

1. **Базовый класс `Fraction`**  
   - Хранит числитель и знаменатель с отдельной нормализацией знака (знак всегда в числителе, знаменатель всегда положителен)
   - Проверяет знаменатель на ноль в конструкторе и выбрасывает `ArgumentException`
   - Реализует арифметические операции через работу с общими знаменателями:
     * Сложение/вычитание: `(a*d ± c*b)/(b*d)`
     * Умножение: `(a*c)/(b*d)`
     * Деление: `(a*d)/(b*c)` с проверкой делителя на ноль
   - Определяет методы `Equals()` и `GetHashCode()` для корректного сравнения дробей (включая эквивалентные: `1/2 == 2/4`)
   - Реализует интерфейс `ICloneable` для создания глубоких копий объектов

2. **Кэширование через шаблоны**  
   - Создан интерфейс `ICachedDouble` с методом `GetCachedValue()`
   - Реализован шаблон `CachedFraction<T>`, который:
     * Наследуется от `Fraction` и реализует `ICachedDouble`
     * Вычисляет и сохраняет вещественное значение дроби **один раз** в конструкторе
     * Работает с любым типом-наследником `Fraction` благодаря ограничению `where T : Fraction`
     * Обеспечивает потенциально высокую производительность при многократных запросах

3. **Арифметические операции**  
   - Все операции создают **новые объекты**, не изменяя исходные (иммутабельность)
   - Поддержка операций с целыми числами через неявное преобразование в дробь `value/1`

### Тестирование задачи 2

- **Тест 2.1**: 0-вой знаменатель  
  Ожидаемый результат: Исключение и вывод ошибки
  - Ошибка выполнения: Знаменатель не может быть равен нулю

- **Тест 2.2**: Символ вместо числа 
  Ожидаемый результат: Исключение и вывод ошибки
  - Ошибка ввода! Введите целое число.

- **Тест 2.3**: Пустой ввод
  Ожидаемый результат: Исключение и вывод ошибки
  - Ошибка ввода!

- **Тест 2.4**: Вещественное число вместо целого
  Ожидаемый результат: Исключение и вывод ошибки
  - Ошибка ввода! Введите целое число.

---
